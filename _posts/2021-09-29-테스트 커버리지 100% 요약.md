---
layout: post
title: "SLASH21 : 테스트 커버리지 100% 요약"
summary: "와닿는 개념만 끄적끄적"
author: 2rohyun
date: '2021-09-29 11:28:00 +0900'
category: semina
thumbnail: /assets/img/posts/tc100.png
keywords: test, coverage
permalink: /blog/tc-hundred-percent/
usemathjax: false
---

# SLASH21 : 테스트 커버리지 100% 요약

#### 테스트 커버리지, 얼마면 될까?

```
얼마만큼의 코드를 자동화한 단위 텍스트로 계산해야 할까?
대답할 필요조차 없다. 모조디 다 해야한다. 모.조.리!

100% 테스트 커버리지를 권장하냐고? 권장이 아니라 강력히 요구한다.
"작성한 코드는 한 줄도 빠짐없이 전부 테스트해야 한다."
군말은 필요 없다.

로버트 마틴 저. 정희종 역.
"클린 코더(2016)"중에서
```

#### 테스트 환경

- Spring Webflux, Kotlin

#### 높은 테스트 커버리지의 이점

- 자신 있게 누를 수 있는 배포 버튼
  - 모든 코드가 테스트되었다는 사실에서 오는 자신감
- 거침없는 리팩토링
  - 리팩토링에 문제가 있다면 테스트가 알려줄 것이다!
- 불필요한 프로덕션 코드가 사라진다
  - 남아 있따면 그것 또한 테스트해야 한다.
- 프로덕션 코드에 대한 이해도 상승
  - 이해가 충분하지 못하면 테스트를 작성할 수 없다.
- 점점 쉬워지는 테스트 작성
  - 프로덕션 코드가 테스트를 작성하기 쉽도록 변해간다
  - 이미 작성한 테스트를 참고해 새 테스트를 작성할 수 있다.

#### 테스트 커버리지를 높이기 위해 필요한 것들

- 믿음 
  - 테스트가 필요하다는 믿음이 있어야 한다. 
  - 테스트를 하지 않은 코드는 리팩토링을 할 수 없고, 리팩토링을 하지 않은 코드는 이해할 수 없게 되며, 이해할 수없는 코드는 수정할 수 없다.
  - 어떠한 코드도 테스트할 수 있다는 믿음도 있어야 한다.
- 시간
  - 테스트 코드를 작성해야할 시간이 있어야 한다.
  - 테스트 커버리지를 낮은 상태에서 끌어올리려면 많은 시간이 투자된다. 따라서 프로젝트 초기부터 테스트를 작성해야 한다.

- 필요하지 않은 것
- 의지
  - jacoco 플러그인의 jacocoTestCoverageVerification 을 사용해 테스트 커버리지가 지정한 수치 미만이면 빌드가 실패하도록 한다.

#### 어려움

1. 느려지는 테스트, 테스트가 느려지면 생산성이 떨어진다.
  - 가장 큰 느려지는 원인 : 스프링 애플리케이션 컨텍스트 로딩
  - 해결
    - 스프링 애플리케이션 컨텍스트 로딩 제거
    - 많은 스프링 웹 애플리케이션 테스트 프레임워크들은 컨텍스트 로딩없이 HTTP API 를 테스트할 수 있게 해주는 standalone 기능을 제공하고 있다.
    - 다만 애플리케이션 실행 시, 스프링 애플리케이션이 기동되는지를 테스트 할 때는 애플리케이션 컨텍스트 로딩만 제거하는 것은 상당히 어렵기 때문에 모킹 라이브러리의 Static Mocking 기능을 이용해 스프링을 모킹해서 실제로 스프링 애플리케이션을 기동하지 않고, SpringApplication.run() 이 호출되는지만 확인!

- 테스트 코드가 늘어나자 다시 테스트가 느려졌고, InteliJ 에 내장된 프로파일러인 async-profiler 를 이용해 테스트 코드를 성능 프로파일링해본 결과, 다시 느려진 원인을 찾았다.

2. 다시 느려진 원인 및 해결책

![slowreason](/assets/img/posts/slowreason.png){: width="70%" height="70%"}

- SLF4J 가 느린 것은 설정파일 파싱 때문이므로, 테스트에서 필요하지 않은 로깅 설정을 제거
- Handlebars 컴파일이 느린 문제는 캐시 적용으로 갇단히 해결
- Jackson ObjectMapper() 생성이 느린 문제는 Gson 으로 대체하여 해결
- Byte buddy 는 dummy 테스트 생성을 위해 사용하고 있었지만 너무 느리므로 제거
- 코틀린 리플렉션 모듈 초기화를 유발하는 것으로 보이는 isSubclassOf 함수 호출 제거
- 가장 치명적인 MockK 역시, Static Mocking 한 번을 제외하고 모두 제거, 모킹이 필요한 경우 MockK 를 쓰지 않고 직접 목 오브젝트를 구현함.
- Junit 테스트 설정을 고쳐, 클래스 단위로 병렬 실행되도록 했음. 함수 단위로 병렬 실행도 가능했지만, 동시성 문제로 테스트가 실패하는 경우가 많아 클래스 단위로 설정함.

2. 진짜 어려운 테스트

![readhardtest](/assets/img/posts/readhardtest.png){: width="70%" height="70%"}

![elvistest](/assets/img/posts/elvistest.png){: width="70%" height="70%"}

- elvis operator 를 사용한 코드를 바이트 코드로 컴파일 한 뒤, 자바로 다시 역컴파일 해보면 person 의 name 이 null 인지 검사하는 코드가 들어가 있다. 코틀린 코드에서는 name 이 nonnull 임이 보장되지만, JVM 레벨에서 보장되는 것은 아니기 때문에 컴파일 후의 바이트 코드에서는 null 이 맞는지 검사하는 코드가 추가된다.

- 코틀린 코드에서는 nonnull 로 설정된 값이 null 일 순 없기 때문에, person.name 이 null 인 경우를 테스트하기는 대단히 어렵다. 

![elvisif](/assets/img/posts/elvisif.png){: width="70%" height="70%"}

- 해결책 : Elvis operator 를 if 문으로 대체한다.

- 어떻게 해도 테스트가 불가능한 케이스의 경우, 특정 파일을 제외시키는 기능을 활용한다.

#### 왜 그렇게까지 100% 인가

- 새로 추가한 코드가 조금이라도 커버되지 않으면 언제나 실패, 커버리지 리포트를 보고 빠뜨린 곳을 알 수 있다.

#### 그래도 버그는 있다

- 테스트를 잘못 작성하는 경우
  - 테스트 케이스가 부족할 때
    - 기능에 버그가 있어도 테스트가 잡아내지 못한다. 그럼에도 불구하고 테스트 커버리지는 100%가 될수 있다.
    - ex. a + b 를 리턴하는 함수를 테스트 할 때, a = 0, b = 0 / a = 1, b = 0  두 가지 테스트 케이스가 존재하는 경우 a - b 를 리턴하더라도 테스트는 성공한다.
    - 해결책 : Mutation Testing
      - 프로덕션 코드를 무작위로 조작하고 테스트가 통과하면 테스트 케이스가 부족한 것으로 간주
      - pitest.org 라는 도구 활용
      - but, 굉장히 느리므로, 중요한 로직에만 부분적으로 적용하는 것이 좋다!
      - pitest 의 FAQ 를 확인해보면, Mutation testing 은 상당히 많은 연산이 요구되는 비싼 작업이며, 때때로 무한 루프를 유발한다고 명시되어 있다.

- 요구 사항에 오해가 생긴 경우
  - 요구 사항을 작성하는 사람과 구현하는 사람이 다른 사람이라면 언제나 오해의 가능성이 있다.
  - 요구 사항을 작성하는 사람이 테스트를 작성하는 것이 좋지만, 현실적으로 쉽지 않다.
  - 해결책
    - 테스트로 스펙 문서를 만들어 요구 사항을 작성한 사람에게 전달한다.
    - Junit5 의 TestExecutionListener
      - 테스트 실행시마다 테스트의 이름 수집 기능을 활용해 수집한 테스트의 DisplayName 으로 스펙 문서 생성 도구를 개발
       
- 컴포넌트간 협업이 실패한 경우
  - 나의 서버와 협업하는 다른 서버의 컴포넌트에 문제가 있는 경우가 종종 있다.
  - 해결책
    - Consumer Driven Contracts : API 를 사용하는 쪽, 즉 Consumer 가 요구 사항을 machine readable 하게 기술하면 API 를 제공하는 쪽, Provider 가 요구 사항을 만족하는지 테스트하는 것.
    - Spring Cloud Contract vs. Pact
       - Pact 는 컴포넌트 간의 계약을 관리해주는 Pactflow 라는 편리한 웹 서비스가 존재한다.

#### 결론

- 테스트 커버리지는 얼마든지 높일 수 있다.
- 테스트 커버리지가 낮으면 빌드 실패하게 하자
- 테스트는 빨라야 한다.
- 커버리지가 100%라도 버그는 있다.
₩
## REFERENCES
[테스트 커버리지 100%](https://www.youtube.com/watch?v=jdlBu2vFv58)



