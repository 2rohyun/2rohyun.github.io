---
layout: post
title:  "토비의 스프링 #1"
summary: "나에게 와닿는 개념만 끄적끄적"
author: 2rohyun
date: '2021-04-23 17:45:00 +0900'
category: spring
thumbnail: /assets/img/posts/springboot.png
keywords: toby, spring, toby's spring
permalink: /blog/toby-spring-first/
usemathjax: false
---

# 토비의 스프링 #1

### 1.4 제어의 역전 ( IoC )

1. 제어의 역전에서는 오브젝트가 자신이 사용할 오브젝트를 스스로 선택하지 않는다. 당연히 생성하지도 않는다. 또 자신도 어떻게 만들어지고 어디서 사용되는지를 알 수 없다. 모든 제어 권한을 자신이 아닌다른 대상에게 위임하기 때문이다. 프로그램의 시작을 담당하는 `엔트리 포인트`를 제외하면 모든 오브젝트는 이렇게 위임받은 제어 권한을 갖는 특별한 오브젝트에 의해 결정되고 만들어진다.

2. `서블릿` 을 생각해보자. 서블릿 안에 main() 메소드가 있어서 직접 실행시킬 수 있는 것도 아니다. 대신 서블릿에 대한 제어 권한을 가진 컨테이너가 적절한 시점에 서블릿 클래스의 오브젝트를 만들고 그 안의 메소드를 호출한다. 이렇게 서블릿이나 `JSP, EJB`처럼 컨테이너 안에서 동작하는 구조는 간단한 방식이긴 하지만 제어의 역전 개념이 적용되어 있다고 볼 수 있다.

3. DaoFactory 를 분리했을 때 얻을 수 있는 장점은 매우 다양하다. 그중에서도 애플리케이션 컴포넌트 역할을 하는 오브젝트와 애플리케이션의 구조를 결정하는 오브젝트를 분리했다는 데 가장 의미가 있다.

4. 라이브러리를 사용하는 애플리케이션 코드는 애플리케이션 흐름을 직접 제어한다. 단지 동작하는 중에 필요한 기능이 있을 때 능동적으로 라이브러리를 사용할 뿐이다. 반면에 프레임워크는 거꾸로 애플리케이션 코드가 프레임워크에 의해 사용된다. 보통 프레임워크 위에 개발한 클래스를 등록해두고, 프레임워크가 흐름을 주도하는 중에 개발자가 만든 애플리케이션 코드를 사용하도록 만드는 방식이다.

5. 우리가 만든 UserDao 와 DaoFactory 에도 제어의 역전이 적용되어 있다. 원래 ConnectionMaker 의 구현 클래스를 결정하고 오브젝트를 만드는 제어권은 UserDao 에게 있었다. 그런데 지금은 DaoFactory 에게 있다. 자신이 어떤 ConnectionMaker 구현 클래스를 만들고 사용할지를 결정할 권한을 DaoFactory 에 넘겼으니 UserDao 는 이제 능동적이 아니라 수동적인 존재가 됐다. UserDao 자신도 팩토리에 의해 수동적으로 만들어지고 자신이 사용할 오브젝트도 DaoFactory 가 공급해주는 것을 수동적으로 사용해야 할 입장이 됐다. UserDaoTest 는 DaoFactory 가 만들고 초기화해서 자신에게 사용하도록 공급해주는 ConnectionMaker 를 사용할 수밖에 없다. 더욱이 UserDao 와 ConnectionMaker 의 구현체를 생성하는 책임도 DaoFactory 가 맡고 있다. 바로 이것이 제어의 역전이 일어난 상황이다. 자연스럽게 관심을 분리하고 책임을 나누고 유연하게 확장 가능한 구조로 만들기 위해 DaoFactory 를 도입했던 과정이 바로 IoC 를 적용하는 작업이었다고 볼 수 있다.

    ```java
    public class DaoFactory() {
        public UserDao userDao() {
            return new UserDao(connectionMaker());
        }

        public AccountDao accountDao() {
            return new AccountDao(connectionMaker());
        }

        public ConnectionMaker connectionMaker(){
            return new DConnectionMaker(); // 분리해서 중복을 제거한 ConnectionMaker 타입 오브젝트 생성 코드
        }
    }
    ```

6. IoC 는 기본적으로 프레임워크만의 기술도 아니고 프레임워크가 꼭 필요한 개념도 아니다. 단순하게 생각하면 디자인 패턴에서도 발견할 수 있는 것처럼 상당히 폭넓게 사용되는 프로그래밍 모델이다. IoC 를 적용함으로써 설계가 깔끔해지고 유연성이 증가하며 확장성이 좋아지기 때문에 필요할 때면 IoC 스타일의 설계와 코드를 만들어 사용하면 된다.

### 1.5 스프링의 IoC

1. 마치 건물이 설계도면을 따라서 만들어지듯이, 애플리케이션도 애플리케이션 컨텍스트와 그 설정정보를 따라서 만들어지고 구성된다고 생각할 수 있다.

2. DaoFactory 가 UserDao 를 비롯한 DAO 오브젝트를 생성하고 DB 생성 오브젝트와 관계를 맺어주는 제한적인 역할을 하는 데 반해, 애플리케이션 컨텍스트는 애플리케이션에서 IoC 를 적용해서 관리할 모든 오브젝트에 대한 생성과 관계설정을 담당한다. 대신  ApplicationContext 에는 DaoFactory 와 달리 직접 오브젝트를 생성하고 관계를 맺어주는 코드가 없고, 그런 생성정보와 연관관계 정보를 별도의 설정정보를 통해 얻는다.

3. 애플리케이션 컨텍스트는 DaoFactory 클래스를 설정정보로 등록해두고 @Bean 이 붙은 메소드 이름을 가져와 빈 목록을 만들어둔다. 클라이언트가 애플리케이션 컨텍스트의 getBean() 메소드를 호출하면 자신의 빈 목록에서 요청한 이름이 있는지 찾고, 있다면 빈을 생성하는 메소드를 호출해서 오브젝트를 생성시킨 후 클라이언트에 되돌려준다.

4. DaoFactory 를 오브젝트 팩토리로 직접 사용했을 때와 비교해서 어플리케이션 컨텍스트를 사용했을 때 얻을 수 있는 장점

    [1]. 클라이언트는 구체적인 팩토리 클래스를 알 필요가 없다.
        - 애플리케이션 컨텍스트를 사용하면 오브젝트 팩토리가 아무리 많아져도 이를 알아야하거나 직접 사용할 필요가 없다. 또, DaoFactory 처럼 자바 코드를 작성하는 대신 XML 처럼 단순한 방법을 사용해 애플리케이션 컨텍스트가 사용할 IoC 설정정보를 만들 수도 있다.
    
    [2]. 애프리케이션 컨텍스트는 종합 IoC 서비스를 제공해준다.
        - 오브젝트가 만들어지는 방식, 시점과 전략을 다르게 가져갈 수도 있고, 이에 부가적으로 자동생성, 오브젝트에 대한 후처리, 정보의 조합, 설정 방식의 다변화, 인터셉팅 등 오브젝트를 효과적으로 활용할 수 있는 다양한 기능을 제공한다.
    
    [3]. 애플리케이션 컨텍스트는 빈을 검색하는 다양한 방법을 제공한다.
        - 애플리케이션 컨텍스트의 getBean() 메소드는 빈의 이름을 이용해 빈을 찾아준다.

5. 스프링 IoC 의 용어 정리

    [1]. Bean :  스프링이 IoC 방식으로 관리하는 오브젝트, 주의할 점은 스프링을 사용하는 애플리케이션에서 만들어지는 모든 오브젝트가 다 빈은 아니라는 사실이다. 그중에서 스프링이 직접 그 생성과 제어를 담당하는 오브젝트만을 빈이라고 부른다.

    [2]. Bean Factory : 스프링의 IoC 를 담당하는 핵심 컨테이너, 빈을 등록하고, 생성하고, 조회하고 돌려주고, 그 외에 부가적인 빈을 관리하는 기능을 담당한다. 보통은 이 빈 팩토리를 바로 사용하지 않고 이를 확장한 애플리케이션 컨텍스트를 이용한다.

    [3]. Application Context : 빈 팩토리를 확장한 IoC 컨테이너, 기본 기능은 빈 팩토리와 동일하고, 여기에 스프링이 제공하는 각종 부가 서비스를 추가로 제공한다. 빈 팩토리라고 부를 때는 주로 빈의 생성과 제어의 관점에서 이야기하는 것이고, 애플리케이션 컨텍스트라고 할 때는 스프링이 제공하는 애플리케이션 지원 기능을 모두 포함해서 이야기하는 것이라고 보면 된다.

    [4]. Configuration Metadata : 애플리케이션 컨텍스트가 IoC 를 적용하기 위해 사용하는 메타정보, IoC 컨테이너에 의해 관리되는 애플리케이션 오브젝트를 생성하고 구성할 때 사용된다.

### 1.6 싱글톤 레지스트리와 오브젝트 스코프

1. 오브젝트의 동일성과 동등성 : 두 개의 오브젝트가 동일하다면 사실은 하나의 오브젝트만 존재하는 것이고 두 개의 오브젝트 레퍼런스 변수를 갖고 있을 뿐이다. 두 개의 오브젝트가 동일하지는 않지만 동등한 경우에는 두 개의 각기 다른 오브젝트가 메모리 상에 존재하는 것인데, 오브젝트의 동등성 기준에 따라 두 오브젝트의 정보가 동등하다고 판단하는 것일 뿐이다. 물론 동일한 오브젝트는 동등하기도 할 것이다. 하지만 그 반대는 항상 참은 아니다.

2. 애플리케이션 컨텍스트는 싱글톤을 저장하고 관리하는 싱글톤 레지스트리이기도 하다.

3. 왜 스프링은 싱글톤으로 빈을 만드는 것일까? 이는 스프링이 주로 적용되는 대상이 자바 엔터프라이즈 기술을 사용하는 서버환경이기 때문이다. ~ 매번 클라이언트에서 요청이 올 때마다 각 로직을 담당하는 오브젝트를 새로 만들어서 사용한다고 생각해보자. 아무리 자바의 오브젝트 생성과 `가비지 컬렉션` 의 성능이 좋아졌다고 한들 이렇게 부하가 걸리면 서버가 감당하기 힘들다.

4. 서블릿은 자바 엔터프라이즈 기술의 가장 기본이 되는 서비스 오브젝트라고 할 수 잇다. 서블릿은 대부분 `멀티스레드` 환경에서 싱글톤으로 동작한다.

5. 일반적인 싱글톤 패턴 구현 방식의 문제점

    [1]. private 생성자를 갖고 있기 때문에 상속할 수 없다.
        - private 생성자를 가진 클래스는 다른 생성자가 없다면 상속이 불가능, 객체지향의 장점인 상속과 이를 이용한 다형성을 적용할 수 없다. 
    
    [2]. 싱글톤은 테스트하기 힘들다.
        - 만들어지는 방식이 제한적이기 때문에 테스트에서 사용될 때 목 오브젝트 등으로 대체하기가 힘들다. 테스트는 엔터프라이즈 개발의 핵심인데 테스트에 지장이 있다는 건 큰 단점이다.
    
    [3]. 서버환경에서는 싱글톤이 하나만 만들어지는 것을 보장하지 못한다.
        - 서버에서 `클래스 로더` 를 어떻게 구성하고 있느냐에 따라서 싱글톤 클래스임 에도 하나 이상의 오브젝트가 만들어 질 수 있다. 따라서 자바 언어를 이용한 싱글톤 패턴 기법은 서버 환경에서는 싱글톤이 꼭 보장된다고 볼 수 없다.
    
    [4]. 싱글톤의 사용은 전역 상태를 만들 수 있기 때문에 바람직하지 못하다.
        - 싱글톤의 스태틱 메소드를 이용해 언제든지 싱글톤에 쉽게 접근할 수 있기 때문에 애프리케이션 어디서든지 사용될 수 있고, 그러다 보면 자연스럽게 전역 상태로 사용되기 쉽다.

6. 싱글톤 레지스트리의 장점은 스태틱 메소드와 private 생성자를 사용해야 하는 비정상적인 클래스가 아니라 평범한 자바 클래스를 싱글톤으로 활용하게 해준다는 점이다. ~ 싱글톤 방식으로 사용될 애플리케이션 클래스라도 public 생성자를 가질 수 있다. ~ 가장 중요한 것은 싱글톤 패턴과 달리 스프링이 지지하는 객체지향적인 설계 방식과 원칙, 디자인 패턴 등을 적용하는 데 아무런 제약이 없다는 점이다.

7. 다중 사용자의 요청을 한꺼번에 처리하는 스레드들이 동시에 싱글톤 오브젝트의 인스턴스 변수를 수정하는 것은 매우 위험하다. 따라서 무상태 ( stateless ) 방식으로 만들어져야 한다. 상태가 없는 방식으로 클래스를 만드는 경우에 각 요청에 대한 정보나, DB 나 서버의 리소스로부터 생성한 정보는 어떻게 다뤄야 할까? 이때는 파라미터와 로컬 변수, 리턴 값 등을 이용하면 된다. 메소드 안에서 생성되는 로컬 변수는 매 번 새로운 값을 저장할 독립적인 공간이 만들어지기 때문에 싱글톤이라고 해도 여러 스레드가 변수의 값을 덮어쓸 일은 없다.

8. 빈의 스코프는 스프링이 관리하는 오브젝트, 즉 빈이 생성되고, 존재하고, 적용되는 범위이다. 싱글톤 스코프는 컨테이너 내에 한 개의 오브젝트만 만들어져서, 강제로 제거하지 않는 한 스프링 컨테이너가 존재하는 동안 계속 유지된다. 스프링에서 만들어지는 대부분의 빈은 싱글톤 스코프를 갖는다.

### 1.7 의존관계 주입 ( DI )

1. 프로그램이 시작되고 UserDao 오브젝트가 만들어지고 나서 런타임 시에 의존관계를 맺는 대상, 즉 실제 사용대상인 오브젝트를 의존 오브젝트라고 말한다.

2. 의존관계 주입이란 다음과 같은 세 가지 조건을 충족하는 작업을 말한다.
    - 클래스 모델이나 코드에는 런타임 시점의 의존관계가 드러나지 않는다. 그러기 위해서는 인터페이스에만 의존하고 있어야 한다.
    - 런타임 시점의 의존관계는 컨테이너나 팩토리 같은 제3의 존재가 결정한다.
    - 의존관계는 사용할 오브젝트에 대한 레퍼런스를 외부에서 제공( 주입 ) 해줌으로써 만들어진다.


3. DI 에서 말하는 제3의 존재는 바로 관계설정 책임을 가진 코드를 분리해서 만들어진 오브젝트라고 볼 수 있다. ~ 스프링의 애플리케이션 컨텍스트, 빈 팩토리, IoC 컨테이너 등이 모두 외부에서 오브젝트 사이의 런타임 관계를 맺어주는 책임을 지닌 제3의 존재라고 볼 수 있다.

4. DaoFactory 는 런타임 시점에 UserDao 가 사용할 ConnectionMaker 타입의 오브젝트를 결정하고 이를 생성한 후에 UserDao 의 생성자 파라미터로 주입해서 UserDao 가 DConnetionMaker 의 오브젝트와 런타임 의존관계를 맺게 해준다. 따라서 의존관계 주입의 세 가지 조건을 모두 충족한다고 볼 수 있고, 이미 DaoFactory 를 만든 시점에서 의존관계 주입을 이용한 셈이다.

5. 의존관계 검색은 런타임 시 의존관계를 맺을 오브젝트를 결정하는 것과 오브젝트 생성 작업은 외부 컨테이너에게 IoC 로 맡기지만, 이를 가져올 때는 메소드나 생성자를 통한 주입 대신 스스로 컨테이너에게 요청하는 방법을 사용한다. 

6. 스프링의 IoC 컨테이너인 애플리케이션 컨텍스트는 getBean() 이라는 메소드를 제공한다. 바로 이 메소드가 의존관계 검색에 사용되는 것이다. ~ 의존관계 검색 방법은 코드 안에 오브젝트 팩토리 클래스나 스프링 API 가 나타난다. 애플리케이션 컴포넌트가 컨테이너와 같이 성격이 다른 오브젝트에 의존하게 되는 것이므로 그다지 바람직하지 않다.

    ```java
    public UserDao(){
        AnnotationConfigApplicationContext context = new AnnotationConfigApplicationContext(DaoFactory.class);
        this.connectionMaker = context.getBean("connectionMaker", ConnectionMaker.class);
    }
    ```

7. DI 기술의 장점은 앞서 설명한 모든 객체지향 설계와 프로그래밍 원칙을 따랐을 때 얻을 수 있는 장점이 그대로 적용된다. 코드에는 런타임 클래스에 대한 의존관계가 나타나지 않고, 인터페이스를 통해 결합도가 낮은 코드를 만들므로, 다른 책임을 가진 사용 의존관계에 있는 대상이 바뀌거나 변경되더라도 자신은 영향을 받지 않으며, 변경을 통한 다양한 확장 방법에는 자유롭다.

### 1장을 마치여

스프링이란 '어떻게 오브젝트가 설계되고, 만들어지고, 어떻게 관계를 맺고 사용되는지에 관심을 갖는 프레임워크' 라는 사실을 꼭 기억해두자. 스프링의 관심은 오브젝트와 그 관계이다. 하지만 오브젝트를 어떻게 설계하고, 분리하고, 개선하고, 어떤 의존관계를 가질지 결정하는 일은 스프링이 아니라 개발자의 역할이며 책임이다. 스프링은 단지 원칙을 잘 따르는 설계를 적용하려고 할 때 필연적으로 등장하는 번거로운 작업을 편하게 할 수 있도록 도와주는 도구일 뿐임을 잊지말자.

